{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///Quadtree.min.js","webpack:///webpack/bootstrap 8a16fe4abd4022e3223b","webpack:///./src/ts/Quadtree.ts","webpack:///./src/ts/Bounds.ts","webpack:///./src/ts/util.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","createQuad","bounds","_bounds","_nodes","_quads","createQuadFromRect","x","y","width","height","Bounds_1","createNode","value","_value","getQuadIndex","quad","node","index","yOffset","xOffset","nodeBounds","valueBounds","leftX","rightX","topY","bottomY","middleX","middleY","splitQuad","maxItems","childQuad","insertIndex","quads","nodes","depthAdded","length","splice","insertNodeIntoQuad","hasNodes","push","validateMaxItems","undefined","DEFAULT_MAX_ITEMS","parsedMaxItems","parseInt","TypeError","intersectsBoundingBox","bounded","boundingBox","intersectsPoint","point","createBounds","createPoint","util_1","validateNumber","findIntersectingNodes","testArea","nodeIntersectionTest","results","nodeIndex","queryIntersection","quadtree","intersects","childQuadIndex","queue","queueIndex","Quadtree","_depth","_size","_maxItems","parsedBounds","prototype","clear","isEmpty","getMaxItems","getDepth","getSize","queryWithBoundingBox","queryWithPoint","parsedPoint","insert","Bounds","RangeError","Object","defineProperty","propertyName","isFinite","Number"],"mappings":"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","file":"Quadtree.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Quadtree\"] = factory();\n\telse\n\t\troot[\"Quadtree\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Quadtree\"] = factory();\n\telse\n\t\troot[\"Quadtree\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Bounds_1 = __webpack_require__(1);\n\tvar util_1 = __webpack_require__(2);\n\tvar DEFAULT_MAX_ITEMS = 4;\n\tfunction createQuad(bounds) {\n\t    return {\n\t        _bounds: bounds,\n\t        _nodes: [],\n\t        _quads: [],\n\t        id: ''\n\t    };\n\t}\n\tfunction createQuadFromRect(x, y, width, height) {\n\t    var bounds = new Bounds_1.default(x, y, width, height);\n\t    return createQuad(bounds);\n\t}\n\tfunction createNode(bounds, value) {\n\t    return {\n\t        _bounds: bounds,\n\t        _value: value\n\t    };\n\t}\n\tfunction getQuadIndex(quad, node) {\n\t    var index = -1, yOffset = 0, xOffset = 0;\n\t    var nodeBounds = quad._bounds, valueBounds = node._bounds;\n\t    var leftX = valueBounds.leftX, rightX = valueBounds.rightX, topY = valueBounds.topY, bottomY = valueBounds.bottomY, middleX = nodeBounds.middleX, middleY = nodeBounds.middleY;\n\t    if (nodeBounds.leftX > valueBounds.leftX || nodeBounds.rightX < rightX) {\n\t        return index;\n\t    }\n\t    if (nodeBounds.topY > valueBounds.topY || nodeBounds.bottomY < bottomY) {\n\t        return index;\n\t    }\n\t    if (rightX > middleX) {\n\t        if (leftX < middleX) {\n\t            return index;\n\t        }\n\t        xOffset = 1;\n\t    }\n\t    if (bottomY > middleY) {\n\t        if (topY < middleY) {\n\t            return index;\n\t        }\n\t        yOffset = 2;\n\t    }\n\t    return xOffset + yOffset;\n\t}\n\tfunction splitQuad(quad, maxItems) {\n\t    var bounds = quad._bounds, quads = quad._quads, nodes = quad._nodes;\n\t    var depthAdded = 0, childQuad, node, index, insertIndex;\n\t    var x = bounds.leftX, y = bounds.topY, middleX = bounds.middleX, middleY = bounds.middleY, width = bounds.width / 2, height = bounds.height / 2;\n\t    quads[0] = createQuadFromRect(x, y, width, height);\n\t    quads[0].id = quad.id + '0';\n\t    quads[1] = createQuadFromRect(middleX, y, width, height);\n\t    quads[1].id = quad.id + '1';\n\t    quads[2] = createQuadFromRect(x, middleY, width, height);\n\t    quads[2].id = quad.id + '2';\n\t    quads[3] = createQuadFromRect(middleX, middleY, width, height);\n\t    quads[3].id = quad.id + '3';\n\t    index = nodes.length - 1;\n\t    while (index >= 0) {\n\t        node = nodes[index];\n\t        insertIndex = getQuadIndex(quad, node);\n\t        if (insertIndex !== -1) {\n\t            nodes.splice(index, 1);\n\t            childQuad = quads[insertIndex];\n\t            depthAdded += insertNodeIntoQuad(node, childQuad, maxItems);\n\t        }\n\t        --index;\n\t    }\n\t    return depthAdded;\n\t}\n\tfunction insertNodeIntoQuad(node, quad, maxItems) {\n\t    var quads = quad._quads, hasNodes = quads.length > 0;\n\t    var depthAdded = 0, nodes, index;\n\t    if (hasNodes) {\n\t        index = getQuadIndex(quad, node);\n\t        while (index !== -1) {\n\t            quad = quad._quads[index];\n\t            if (quad._quads.length > 0) {\n\t                index = getQuadIndex(quad, node);\n\t            }\n\t            else {\n\t                index = -1;\n\t            }\n\t        }\n\t    }\n\t    nodes = quad._nodes;\n\t    nodes.push(node);\n\t    if (quad._quads.length === 0 && nodes.length > maxItems) {\n\t        depthAdded += splitQuad(quad, maxItems);\n\t    }\n\t    return depthAdded;\n\t}\n\tfunction validateMaxItems(maxItems) {\n\t    if (maxItems === undefined) {\n\t        return DEFAULT_MAX_ITEMS;\n\t    }\n\t    var parsedMaxItems = parseInt(maxItems);\n\t    if (parsedMaxItems !== maxItems || maxItems <= 0) {\n\t        throw new TypeError('maxItems must be a positive integer.');\n\t    }\n\t    return parsedMaxItems;\n\t}\n\tfunction intersectsBoundingBox(bounded, boundingBox) {\n\t    var nodeBounds = bounded._bounds;\n\t    if (nodeBounds.leftX > boundingBox.rightX || boundingBox.leftX > nodeBounds.rightX) {\n\t        return false;\n\t    }\n\t    return !(nodeBounds.topY > boundingBox.bottomY || boundingBox.topY > nodeBounds.bottomY);\n\t}\n\tfunction intersectsPoint(bounded, point) {\n\t    var nodeBounds = bounded._bounds, x = point.x, y = point.y;\n\t    if (x < nodeBounds.leftX || x > nodeBounds.rightX) {\n\t        return false;\n\t    }\n\t    return !(y < nodeBounds.topY || y > nodeBounds.bottomY);\n\t}\n\tfunction createBounds(bounds) {\n\t    if (bounds === null || typeof bounds === 'undefined') {\n\t        throw new TypeError('bounds parameter must be defined');\n\t    }\n\t    else if (!(bounds instanceof Bounds_1.default)) {\n\t        return new Bounds_1.default(bounds.x, bounds.y, bounds.width, bounds.height);\n\t    }\n\t    return bounds;\n\t}\n\tfunction createPoint(point) {\n\t    if (point === null || typeof point === 'undefined') {\n\t        throw new TypeError('point parameter must be defined');\n\t    }\n\t    return {\n\t        x: util_1.validateNumber(point.x, 'x'),\n\t        y: util_1.validateNumber(point.y, 'y')\n\t    };\n\t}\n\tfunction findIntersectingNodes(quad, testArea, nodeIntersectionTest, results) {\n\t    // this quad intersects, check child nodes\n\t    var nodes = quad._nodes, nodeIndex = nodes.length - 1, node;\n\t    while (nodeIndex >= 0) {\n\t        node = nodes[nodeIndex];\n\t        if (nodeIntersectionTest(node, testArea)) {\n\t            results.push(node._value);\n\t        }\n\t        --nodeIndex;\n\t    }\n\t}\n\tfunction queryIntersection(quadtree, testArea, nodeIntersectionTest) {\n\t    var results = [], queue = [quadtree];\n\t    var queueIndex = 0, intersects, quad, quads, childQuadIndex;\n\t    while (queueIndex >= 0) {\n\t        quad = queue[queueIndex];\n\t        --queueIndex;\n\t        intersects = nodeIntersectionTest(quad, testArea);\n\t        if (intersects) {\n\t            // this node intersects, check children\n\t            findIntersectingNodes(quad, testArea, nodeIntersectionTest, results);\n\t            quads = quad._quads;\n\t            childQuadIndex = quads.length - 1;\n\t            while (childQuadIndex >= 0) {\n\t                queue[++queueIndex] = quads[childQuadIndex];\n\t                --childQuadIndex;\n\t            }\n\t        }\n\t    }\n\t    return results;\n\t}\n\tvar Quadtree = (function () {\n\t    function Quadtree(bounds, maxItems) {\n\t        this._depth = 1;\n\t        this._size = 0;\n\t        this._maxItems = DEFAULT_MAX_ITEMS;\n\t        this._nodes = [];\n\t        this._quads = [];\n\t        this.id = '';\n\t        var parsedBounds = createBounds(bounds);\n\t        if (!(this instanceof Quadtree)) {\n\t            return new Quadtree(parsedBounds, maxItems);\n\t        }\n\t        this._maxItems = validateMaxItems(maxItems);\n\t        this._bounds = parsedBounds;\n\t    }\n\t    Quadtree.prototype.clear = function () {\n\t        this._depth = 0;\n\t        this._size = 0;\n\t        this._quads = [];\n\t        this._nodes = [];\n\t    };\n\t    Quadtree.prototype.isEmpty = function () {\n\t        return this._size === 0;\n\t    };\n\t    Quadtree.prototype.getMaxItems = function () {\n\t        return this._maxItems;\n\t    };\n\t    Quadtree.prototype.getDepth = function () {\n\t        return this._depth;\n\t    };\n\t    Quadtree.prototype.getSize = function () {\n\t        return this._size;\n\t    };\n\t    Quadtree.prototype.queryWithBoundingBox = function (bounds) {\n\t        var boundingBox = createBounds(bounds);\n\t        return queryIntersection(this, boundingBox, intersectsBoundingBox);\n\t    };\n\t    Quadtree.prototype.queryWithPoint = function (point) {\n\t        var parsedPoint = createPoint(point);\n\t        return queryIntersection(this, parsedPoint, intersectsPoint);\n\t    };\n\t    Quadtree.prototype.insert = function (bounds, value) {\n\t        var parsedBounds = createBounds(bounds), node = createNode(parsedBounds, value);\n\t        var depthAdded = insertNodeIntoQuad(node, this, this._maxItems);\n\t        this._depth += depthAdded;\n\t        ++this._size;\n\t    };\n\t    return Quadtree;\n\t}());\n\texports.Quadtree = Quadtree;\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar util_1 = __webpack_require__(2);\n\tvar Bounds = (function () {\n\t    function Bounds(x, y, width, height) {\n\t        // TODO: Make this an interface\n\t        if (!(this instanceof Bounds)) {\n\t            return new Bounds(x, y, width, height);\n\t        }\n\t        if (width < 0) {\n\t            throw new RangeError('width must be >= 0');\n\t        }\n\t        if (height < 0) {\n\t            throw new RangeError('height must be >= 0');\n\t        }\n\t        this.leftX = util_1.validateNumber(x, 'x');\n\t        this.topY = util_1.validateNumber(y, 'y');\n\t        this.width = util_1.validateNumber(width, 'width');\n\t        this.height = util_1.validateNumber(height, 'height');\n\t        this.rightX = x + width;\n\t        this.bottomY = y + height;\n\t        this.middleX = this.rightX - width / 2;\n\t        this.middleY = this.bottomY - height / 2;\n\t    }\n\t    return Bounds;\n\t}());\n\t;\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Bounds;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction validateNumber(value, propertyName) {\n\t    if (!isFinite(value)) {\n\t        throw new TypeError(propertyName + ' must be a finite number');\n\t    }\n\t    return Number(value);\n\t}\n\texports.validateNumber = validateNumber;\n\t;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** Quadtree.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8a16fe4abd4022e3223b\n **/","import Bounds from './Bounds';\nimport {validateNumber} from './util';\n\nconst DEFAULT_MAX_ITEMS:number = 4;\n\ninterface Bounded {\n  _bounds:Bounds\n}\n\ninterface Node extends Bounded {\n  _value:Object\n}\n\ninterface Point {\n  x:number,\n  y:number\n}\n\ninterface Quad extends Bounded {\n  _nodes : Array<Node>,\n  _quads : Array<Quad>\n  id: String\n}\n\ninterface IntersectionTest {\n  (bounded:Bounded, toTest:any):boolean;\n}\n\nfunction createQuad(bounds:Bounds):Quad {\n  return {\n    _bounds: bounds,\n    _nodes: [],\n    _quads: [],\n    id: ''\n  };\n}\n\nfunction createQuadFromRect(x:number, y:number, width:number, height:number) {\n  const bounds:Bounds = new Bounds(x, y, width, height);\n  return createQuad(bounds);\n}\n\nfunction createNode(bounds:Bounds, value:Object):Node {\n  return {\n    _bounds: bounds,\n    _value: value\n  };\n}\n\nfunction getQuadIndex(quad:Quad, node:Node):number {\n  let index:number = -1,\n    yOffset:number = 0,\n    xOffset:number = 0;\n\n  const nodeBounds:Bounds = quad._bounds,\n    valueBounds:Bounds = node._bounds;\n\n  const leftX:number = valueBounds.leftX,\n    rightX:number = valueBounds.rightX,\n    topY:number = valueBounds.topY,\n    bottomY:number = valueBounds.bottomY,\n    middleX:number = nodeBounds.middleX,\n    middleY:number = nodeBounds.middleY;\n\n  if (nodeBounds.leftX > valueBounds.leftX || nodeBounds.rightX < rightX) {\n    return index;\n  }\n\n  if (nodeBounds.topY > valueBounds.topY || nodeBounds.bottomY < bottomY) {\n    return index;\n  }\n\n  if (rightX > middleX) {\n    if (leftX < middleX) {\n      return index;\n    }\n\n    xOffset = 1;\n  }\n\n  if (bottomY > middleY) {\n    if (topY < middleY) {\n      return index;\n    }\n\n    yOffset = 2;\n  }\n\n  return xOffset + yOffset;\n}\n\nfunction splitQuad(quad:Quad, maxItems:number):number {\n  const bounds:Bounds = quad._bounds,\n    quads:Array<Quad> = quad._quads,\n    nodes:Array<Node> = quad._nodes;\n\n  let depthAdded:number = 0,\n    childQuad:Quad,\n    node:Node,\n    index:number,\n    insertIndex:number;\n\n\n  const x:number = bounds.leftX,\n    y:number = bounds.topY,\n    middleX:number = bounds.middleX,\n    middleY:number = bounds.middleY,\n    width:number = bounds.width / 2,\n    height:number = bounds.height / 2;\n\n  quads[0] = createQuadFromRect(x, y, width, height);\n  quads[0].id = quad.id + '0';\n  quads[1] = createQuadFromRect(middleX, y, width, height);\n  quads[1].id = quad.id + '1';\n  quads[2] = createQuadFromRect(x, middleY, width, height);\n  quads[2].id = quad.id + '2';\n  quads[3] = createQuadFromRect(middleX, middleY, width, height);\n  quads[3].id = quad.id + '3';\n\n\n  index = nodes.length - 1;\n  while (index >= 0) {\n    node = nodes[index];\n    insertIndex = getQuadIndex(quad, node);\n\n    if (insertIndex !== -1) {\n      nodes.splice(index, 1);\n      childQuad = quads[insertIndex];\n      depthAdded += insertNodeIntoQuad(node, childQuad, maxItems);\n    }\n\n    --index;\n  }\n\n  return depthAdded;\n}\n\nfunction insertNodeIntoQuad(node:Node, quad:Quad, maxItems:number):number {\n  const quads:Array<Quad> = quad._quads,\n    hasNodes = quads.length > 0;\n\n  let depthAdded:number = 0,\n    nodes:Array<Node>,\n    index:number;\n\n  if (hasNodes) {\n    index = getQuadIndex(quad, node);\n\n    while (index !== -1) {\n      quad = quad._quads[index];\n      if (quad._quads.length > 0) {\n        index = getQuadIndex(quad, node);\n      } else {\n        index = -1;\n      }\n    }\n  }\n\n  nodes = quad._nodes;\n  nodes.push(node);\n  if (quad._quads.length === 0 && nodes.length > maxItems) {\n    depthAdded += splitQuad(quad, maxItems);\n  }\n\n  return depthAdded;\n}\n\nfunction validateMaxItems(maxItems:any) {\n  if (maxItems === undefined) {\n    return DEFAULT_MAX_ITEMS;\n  }\n\n  const parsedMaxItems:number = parseInt(maxItems);\n  if (parsedMaxItems !== maxItems || maxItems <= 0) {\n    throw new TypeError('maxItems must be a positive integer.')\n  }\n\n  return parsedMaxItems;\n}\n\nfunction intersectsBoundingBox(bounded:Bounded, boundingBox:Bounds) {\n  const nodeBounds:Bounds = bounded._bounds;\n\n  if (nodeBounds.leftX > boundingBox.rightX || boundingBox.leftX > nodeBounds.rightX) {\n    return false;\n  }\n\n  return !(nodeBounds.topY > boundingBox.bottomY || boundingBox.topY > nodeBounds.bottomY);\n}\n\nfunction intersectsPoint(bounded:Bounded, point:Point) {\n  const nodeBounds:Bounds = bounded._bounds,\n    x:number = point.x,\n    y:number = point.y;\n\n  if (x < nodeBounds.leftX || x > nodeBounds.rightX) {\n    return false;\n  }\n\n  return !(y < nodeBounds.topY || y > nodeBounds.bottomY);\n}\n\nfunction createBounds(bounds:any):Bounds {\n  if (bounds === null || typeof bounds === 'undefined') {\n    throw new TypeError('bounds parameter must be defined');\n  } else if (!(bounds instanceof Bounds)) {\n    return new Bounds(bounds.x, bounds.y, bounds.width, bounds.height);\n  }\n\n  return bounds;\n}\n\nfunction createPoint(point:any) {\n  if (point === null || typeof point === 'undefined') {\n    throw new TypeError('point parameter must be defined');\n  }\n\n  return {\n    x: validateNumber(point.x, 'x'),\n    y: validateNumber(point.y, 'y')\n  }\n}\n\nfunction findIntersectingNodes(quad:Quad, testArea:any, nodeIntersectionTest:IntersectionTest, results:any[]):void {\n  // this quad intersects, check child nodes\n  let nodes:Node[] = quad._nodes,\n    nodeIndex:number = nodes.length - 1,\n    node:Node;\n\n  while (nodeIndex >= 0) {\n    node = nodes[nodeIndex];\n    if (nodeIntersectionTest(node, testArea)) {\n      results.push(node._value);\n    }\n    --nodeIndex;\n  }\n}\n\nfunction queryIntersection(quadtree:Quadtree, testArea:any, nodeIntersectionTest:IntersectionTest):any[] {\n  const results:any[] = [],\n    queue:Quad[] = [quadtree];\n\n  let  queueIndex:number = 0,\n    intersects:boolean,\n    quad:Quad,\n    quads:Quad[],\n    childQuadIndex:number;\n\n\n  while (queueIndex >= 0) {\n    quad = queue[queueIndex];\n    --queueIndex;\n\n    intersects = nodeIntersectionTest(quad, testArea);\n\n    if (intersects) {\n      // this node intersects, check children\n      findIntersectingNodes(quad, testArea, nodeIntersectionTest, results);\n      quads = quad._quads;\n      childQuadIndex = quads.length - 1;\n      while (childQuadIndex >= 0) {\n        queue[++queueIndex] = quads[childQuadIndex];\n        --childQuadIndex;\n      }\n    }\n  }\n\n  return results;\n}\n\nexport class Quadtree implements Quad {\n  private _depth:number = 1;\n  private _size:number = 0;\n  private _maxItems:number = DEFAULT_MAX_ITEMS;\n  _nodes:Array<Node> = [];\n  _quads:Array<Quad> = [];\n  _bounds:Bounds;\n  id:String = '';\n\n\n  constructor(bounds:Bounds, maxItems:number) {\n    let parsedBounds:Bounds = createBounds(bounds);\n\n    if (!(this instanceof Quadtree)) {\n      return new Quadtree(parsedBounds, maxItems);\n    }\n\n    this._maxItems = validateMaxItems(maxItems);\n    this._bounds = parsedBounds;\n  }\n\n  clear():void {\n    this._depth = 0;\n    this._size = 0;\n    this._quads = [];\n    this._nodes = [];\n  }\n\n  isEmpty():boolean {\n    return this._size === 0;\n  }\n\n  getMaxItems():number {\n    return this._maxItems;\n  }\n\n  getDepth():number {\n    return this._depth;\n  }\n\n  getSize():number {\n    return this._size;\n  }\n\n  queryWithBoundingBox(bounds:any):any[] {\n    const boundingBox:Bounds = createBounds(bounds);\n    return queryIntersection(this, boundingBox, intersectsBoundingBox);\n  }\n\n  queryWithPoint(point:Point):any[] {\n    const parsedPoint = createPoint(point);\n    return queryIntersection(this, parsedPoint, intersectsPoint);\n  }\n\n  insert(bounds:any, value:Object):void {\n    const parsedBounds:Bounds = createBounds(bounds),\n      node = createNode(parsedBounds, value);\n\n    const depthAdded:number = insertNodeIntoQuad(node, this, this._maxItems);\n\n    this._depth += depthAdded;\n    ++this._size;\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/ts/Quadtree.ts\n **/","import {validateNumber} from './util';\n\nclass Bounds {\n  leftX:number;\n  rightX:number;\n  topY:number;\n  bottomY:number;\n  middleX:number;\n  middleY:number;\n  width:number;\n  height:number;\n\n  constructor(x:number, y:number, width:number, height:number) {\n    // TODO: Make this an interface\n\n    if (!(this instanceof Bounds)) {\n      return new Bounds(x, y, width, height);\n    }\n\n    if( width < 0 ){\n      throw new RangeError('width must be >= 0');\n    }\n\n    if( height < 0 ){\n      throw new RangeError('height must be >= 0');\n    }\n\n    this.leftX = validateNumber(x, 'x');\n    this.topY = validateNumber(y, 'y');\n    this.width = validateNumber(width, 'width');\n    this.height = validateNumber(height, 'height');\n\n    this.rightX = x + width;\n    this.bottomY = y + height;\n\n    this.middleX = this.rightX - width / 2;\n    this.middleY = this.bottomY - height / 2;\n  }\n};\n\nexport default Bounds;\n\n\n/** WEBPACK FOOTER **\n ** ./src/ts/Bounds.ts\n **/","export function validateNumber(value:number, propertyName:string):number {\n  if (!isFinite(value)) {\n    throw new TypeError(propertyName + ' must be a finite number');\n  }\n\n  return Number(value);\n};\n\n\n/** WEBPACK FOOTER **\n ** ./src/ts/util.ts\n **/"],"sourceRoot":""}